name: Reusable Docker Build

on:
  workflow_call:
    inputs:
      context:
        required: false
        type: string
        default: '.'
      dockerfile:
        required: false
        type: string
        default: './Dockerfile'
      tag:
        required: false
        type: string
        default: 'real-estate-api:test'
    secrets:
      GITHUB_TOKEN:
        required: false

jobs:
  docker-build:
    name: Docker image build
    runs-on: ubuntu-latest
    permissions:
      contents: read
      checks: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build Docker image
        uses: docker/build-push-action@v5
        with:
          context: ${{ inputs.context }}
          file: ${{ inputs.dockerfile }}
          push: false
          load: true
          tags: ${{ inputs.tag }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Test Docker image
        run: |
          # Cleanup any existing test container
          docker rm -f test-api 2>/dev/null || true

          # Detect if running inside Docker (macOS runners) or on host (server runners)
          if [ -f /.dockerenv ]; then
            echo "Running inside Docker container (macOS runner)"
            # Get current container's network
            RUNNER_NETWORK=$(docker inspect $(hostname) --format='{{range $net, $v := .NetworkSettings.Networks}}{{$net}}{{end}}' 2>/dev/null || echo "bridge")
            echo "Using network: $RUNNER_NETWORK"

            # Run container on same network as runner
            CONTAINER_ID=$(docker run -d --name test-api \
              --network "$RUNNER_NETWORK" \
              -e DB_HOST=postgres \
              -e DB_PORT=5432 \
              -e DB_NAME=test \
              -e DB_USER=test \
              -e DB_PASSWORD=test \
              ${{ inputs.tag }})

            echo "Container started: $CONTAINER_ID"

            # Wait for container to start and show logs
            sleep 5
            echo "Container logs:"
            docker logs test-api

            # Check if container is still running
            if ! docker ps | grep -q test-api; then
              echo "ERROR: Container stopped unexpectedly"
              echo "Full logs:"
              docker logs test-api
              exit 1
            fi

            # Wait a bit more for app to be ready
            sleep 5

            # Check health endpoint from inside the container (avoids DNS issues)
            echo "Checking health endpoint..."
            docker exec test-api curl -f http://localhost:8000/health || {
              echo "Health check failed, container logs:"
              docker logs test-api
              exit 1
            }
          else
            echo "Running on host (server runner)"
            # Run with port mapping for host access
            CONTAINER_ID=$(docker run -d --name test-api -p 8000:8000 \
              -e DB_HOST=localhost \
              -e DB_PORT=5432 \
              -e DB_NAME=test \
              -e DB_USER=test \
              -e DB_PASSWORD=test \
              ${{ inputs.tag }})

            echo "Container started: $CONTAINER_ID"

            # Wait for container to start and show logs
            sleep 5
            echo "Container logs:"
            docker logs test-api

            # Check if container is still running
            if ! docker ps | grep -q test-api; then
              echo "ERROR: Container stopped unexpectedly"
              echo "Full logs:"
              docker logs test-api
              exit 1
            fi

            # Wait a bit more for app to be ready
            sleep 5

            # Check health endpoint via localhost
            echo "Checking health endpoint..."
            curl -f http://localhost:8000/health || {
              echo "Health check failed, container logs:"
              docker logs test-api
              exit 1
            }
          fi

          echo "Container is healthy"

          # Final logs
          echo "Final container logs:"
          docker logs test-api

          # Cleanup
          docker stop test-api
          docker rm test-api

      - name: Check image size
        run: |
          IMAGE_SIZE=$(docker image inspect ${{ inputs.tag }} --format='{{.Size}}')
          IMAGE_SIZE_MB=$((IMAGE_SIZE / 1024 / 1024))
          echo "Image size: ${IMAGE_SIZE_MB}MB"

          if [ $IMAGE_SIZE_MB -gt 200 ]; then
            echo "::warning::Image size (${IMAGE_SIZE_MB}MB) exceeds 200MB target"
          else
            echo "::notice::Image size (${IMAGE_SIZE_MB}MB) is within 200MB target"
          fi
