name: CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

# Required permissions for private repository
permissions:
  contents: read
  pull-requests: read
  checks: write
  statuses: write

jobs:
  changes:
    name: Detect changed files
    uses: ./.github/workflows/reusable-detect-changes.yml

  test:
    name: Unit tests on Python matrix
    needs: changes
    if: needs.changes.outputs.core == 'true' || needs.changes.outputs.tests == 'true' || needs.changes.outputs.ci == 'true'
    strategy:
      fail-fast: false
      matrix:
        python-version: ['3.11', '3.12', '3.13']
    permissions:
      contents: read
      checks: write

    uses: ./.github/workflows/reusable-test.yml
    with:
      python-version: ${{ matrix.python-version }}
    secrets: inherit

  integration-test:
    name: Integration tests
    needs: changes
    if: needs.changes.outputs.core == 'true' || needs.changes.outputs.tests == 'true' || needs.changes.outputs.ci == 'true'
    strategy:
      fail-fast: false
      matrix:
        group: ['database', 'messaging', 'plugins', 'api']
    permissions:
      contents: read
      checks: write

    uses: ./.github/workflows/reusable-integration.yml
    with:
      group: ${{ matrix.group }}
    secrets: inherit

  lint:
    name: Lint and format checks
    needs: changes
    if: needs.changes.outputs.core == 'true' || needs.changes.outputs.tests == 'true' || needs.changes.outputs.ci == 'true'
    permissions:
      contents: read
      checks: write
    uses: ./.github/workflows/reusable-lint.yml
    secrets: inherit

  type-check:
    name: Type checking with mypy
    needs: changes
    if: needs.changes.outputs.core == 'true' || needs.changes.outputs.tests == 'true' || needs.changes.outputs.ci == 'true'
    permissions:
      contents: read
      checks: write
    uses: ./.github/workflows/reusable-typecheck.yml
    secrets: inherit

  security:
    name: Security checks
    needs: changes
    if: needs.changes.outputs.core == 'true' || needs.changes.outputs.tests == 'true' || needs.changes.outputs.ci == 'true'
    permissions:
      contents: read
      checks: write
    uses: ./.github/workflows/reusable-security.yml
    secrets: inherit

  performance-test:
    name: Performance benchmarks
    needs: [changes, test, integration-test, lint, type-check, security]
    if: needs.changes.outputs.core == 'true' || needs.changes.outputs.tests == 'true' || needs.changes.outputs.ci == 'true'
    continue-on-error: true
    permissions:
      contents: read
      checks: write
      pull-requests: write
    strategy:
      matrix:
        python-version: ['3.13']
    uses: ./.github/workflows/reusable-performance.yml
    with:
      python-version: ${{ matrix.python-version }}
    secrets: inherit

  docker-build:
    name: Docker image build
    runs-on: ubuntu-latest
    needs: changes
    if: needs.changes.outputs.core == 'true' || needs.changes.outputs.docker == 'true' || needs.changes.outputs.ci == 'true'
    permissions:
      contents: read
      checks: write

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Build Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./Dockerfile
        push: false
        load: true
        tags: real-estate-api:test
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: Test Docker image
      run: |
        # Cleanup any existing test container
        docker rm -f test-api 2>/dev/null || true

        # Detect if running inside Docker (macOS runners) or on host (server runners)
        if [ -f /.dockerenv ]; then
          echo "Running inside Docker container (macOS runner)"
          # Get current container's network
          RUNNER_NETWORK=$(docker inspect $(hostname) --format='{{range $net, $v := .NetworkSettings.Networks}}{{$net}}{{end}}' 2>/dev/null || echo "bridge")
          echo "Using network: $RUNNER_NETWORK"

          # Run container on same network as runner
          CONTAINER_ID=$(docker run -d --name test-api \
            --network "$RUNNER_NETWORK" \
            -e DB_HOST=postgres \
            -e DB_PORT=5432 \
            -e DB_NAME=test \
            -e DB_USER=test \
            -e DB_PASSWORD=test \
            real-estate-api:test)

          echo "Container started: $CONTAINER_ID"

          # Wait for container to start and show logs
          sleep 5
          echo "Container logs:"
          docker logs test-api

          # Check if container is still running
          if ! docker ps | grep -q test-api; then
            echo "ERROR: Container stopped unexpectedly"
            echo "Full logs:"
            docker logs test-api
            exit 1
          fi

          # Wait a bit more for app to be ready
          sleep 5

          # Check health endpoint from inside the container (avoids DNS issues)
          echo "Checking health endpoint..."
          docker exec test-api curl -f http://localhost:8000/health || {
            echo "Health check failed, container logs:"
            docker logs test-api
            exit 1
          }
        else
          echo "Running on host (server runner)"
          # Run with port mapping for host access
          CONTAINER_ID=$(docker run -d --name test-api -p 8000:8000 \
            -e DB_HOST=localhost \
            -e DB_PORT=5432 \
            -e DB_NAME=test \
            -e DB_USER=test \
            -e DB_PASSWORD=test \
            real-estate-api:test)

          echo "Container started: $CONTAINER_ID"

          # Wait for container to start and show logs
          sleep 5
          echo "Container logs:"
          docker logs test-api

          # Check if container is still running
          if ! docker ps | grep -q test-api; then
            echo "ERROR: Container stopped unexpectedly"
            echo "Full logs:"
            docker logs test-api
            exit 1
          fi

          # Wait a bit more for app to be ready
          sleep 5

          # Check health endpoint via localhost
          echo "Checking health endpoint..."
          curl -f http://localhost:8000/health || {
            echo "Health check failed, container logs:"
            docker logs test-api
            exit 1
          }
        fi

        echo "Container is healthy"

        # Final logs
        echo "Final container logs:"
        docker logs test-api

        # Cleanup
        docker stop test-api
        docker rm test-api

    - name: Check image size
      run: |
        IMAGE_SIZE=$(docker image inspect real-estate-api:test --format='{{.Size}}')
        IMAGE_SIZE_MB=$((IMAGE_SIZE / 1024 / 1024))
        echo "Image size: ${IMAGE_SIZE_MB}MB"

        if [ $IMAGE_SIZE_MB -gt 200 ]; then
          echo "::warning::Image size (${IMAGE_SIZE_MB}MB) exceeds 200MB target"
        else
          echo "::notice::Image size (${IMAGE_SIZE_MB}MB) is within 200MB target"
        fi

  self_hosted_demo:
    name: Self-hosted runner demo
    # This job intentionally runs on any available self-hosted runner to demonstrate
    # that self-hosted runners accept jobs. It is unconditional (runs on every push).
    # Temporarily disabled for demo (avoid claiming self-hosted availability)
    if: false
    runs-on: [self-hosted]
    permissions:
      contents: read

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Show runner environment (demo)
      run: |
        echo "--- Runner / Environment Demo ---"
        echo "GITHUB_RUN_ID=$GITHUB_RUN_ID"
        echo "GITHUB_RUN_NUMBER=$GITHUB_RUN_NUMBER"
        echo "RUNNER_NAME=$RUNNER_NAME"
        echo "RUNNER_OS=$RUNNER_OS"
        echo "RUNNER_TOOL_CACHE=$RUNNER_TOOL_CACHE"
        echo "--- uname ---"
        uname -a || true
        echo "--- env (partial) ---"
        env | sort | sed -n '1,200p'
        echo "--- docker status (if available) ---"
        docker --version || true
        docker ps -a || true
